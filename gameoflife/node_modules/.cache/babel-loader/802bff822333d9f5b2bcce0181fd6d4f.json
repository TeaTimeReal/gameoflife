{"ast":null,"code":"import _classCallCheck from\"/home/rootuser/Desktop/GameOfLife/gameoflife/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/rootuser/Desktop/GameOfLife/gameoflife/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"/home/rootuser/Desktop/GameOfLife/gameoflife/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/home/rootuser/Desktop/GameOfLife/gameoflife/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import'./App.css';import{Component}from'react';import Rows from'./Rows.js';import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var App=/*#__PURE__*/function(_Component){_inherits(App,_Component);var _super=_createSuper(App);function App(props){var _this;_classCallCheck(this,App);_this=_super.call(this,props);_this.onCellClick=function(indexCol,indexRow){var gridTMP=_this.state.gridArray;gridTMP[indexRow][indexCol]=!gridTMP[indexRow][indexCol];_this.setState({gridArray:gridTMP});};_this.state={//gridArray:[ [ \"1\", \"2\", \"3\"], [ \"4\", \"5\" , \"6\"], [ \"6\", \"7\" , \"8\"] ],\n//gridArray:[ [ true, false, false], [ false, true , false], [ true, false , true] , [ false, false , false]],\ngridArray:[],biggergridArray:[],gridXLength:100,gridYLength:100};return _this;}// When clicked on a Cell, then switch that cells status.\n_createClass(App,[{key:\"stepFunction\",value:// Function to call when the button is clicked.\nfunction stepFunction(){var _this2=this;var interval=setInterval(function(){return _this2.calculateNextGeneration();},200);//this.calculateNextGeneration()\n}// Function to calculate the next generation of hte current grid,\n// according to the rules of the game of life.\n},{key:\"calculateNextGeneration\",value:function calculateNextGeneration(){var gridTMP=this.state.gridArray;var newgridTMP=this.state.gridArray;var biggerGrid=[];var index1;// Fill the bigger Grid with false.\nfor(index1=0;index1<this.state.gridYLength+2;index1++){var index2=void 0;var row=[];for(index2=0;index2<this.state.gridXLength+2;index2++){// If the current cell is on the outermost loop of the bigger grid, fill it with false.\nif(index1==0||index1==this.state.gridYLength+1||index2==0||index2==this.state.gridXLength+1){row.push(false);//console.log(index1 + \" \" + index2);\n}// If the current cell is NOT on the outermost loop of the bigger grid, fill it with the content the the grid.\nelse{row.push(gridTMP[index1-1][index2-1]);}}biggerGrid.push(row);}for(index1=0;index1<this.state.gridYLength+2;index1++){var _index=void 0;var _row=[];for(_index=0;_index<this.state.gridXLength+2;_index++){// If the current cell is NOT on the outermost loop of the bigger grid, do the game of life things.\nif(!(index1==0||index1==this.state.gridYLength+1||_index==0||_index==this.state.gridXLength+1)){var GridAroundCurrentCell3x3=[];var index3=void 0;for(index3=0;index3<3;index3++){var index4=void 0;var _row2=[];for(index4=0;index4<3;index4++){_row2.push(biggerGrid[index1-1+index3][_index-1+index4]);}GridAroundCurrentCell3x3.push(_row2);}var cellsAlive=0;// Count the number of alive cells in the current 3x3 grid.\nfor(index3=0;index3<3;index3++){var _index2=void 0;for(_index2=0;_index2<3;_index2++){if(GridAroundCurrentCell3x3[index3][_index2]==true){cellsAlive++;}}}// Simply reduce number of Cells alive by one if the current cell is alive itself.\nif(GridAroundCurrentCell3x3[1][1]==true){cellsAlive--;}// Check for which rule to apply.\nif(cellsAlive<2){newgridTMP[index1-1][_index-1]=false;}if(cellsAlive>=4){newgridTMP[index1-1][_index-1]=false;}if(cellsAlive===3&&GridAroundCurrentCell3x3[1][1]==false){newgridTMP[index1-1][_index-1]=true;}if(cellsAlive===3&&GridAroundCurrentCell3x3[1][1]==true){}if(cellsAlive===2){}}}biggerGrid.push(_row);}this.setState({biggergridArray:biggerGrid});this.setState({gridArray:newgridTMP});//this.setState({ gridArray: biggerGrid});  // Use this line instead of the one above, to display the bigger grid instead of the original. \n}},{key:\"determineArrayDimensions\",value:function determineArrayDimensions(){var yLengthTMP=this.state.gridArray.length;var xLengthTMP=this.state.gridArray.reduce(function(x,y){return Math.max(x,y.length);},0);this.setState({gridXLength:xLengthTMP});this.setState({gridYLength:yLengthTMP});}},{key:\"fillGrid\",value:function fillGrid(){var gridTMP=this.state.gridArray;var index1;// Fill Grid with false.\nfor(index1=0;index1<this.state.gridYLength;index1++){var index2=void 0;var row=[];for(index2=0;index2<this.state.gridXLength;index2++){row.push(false);}gridTMP.push(row);}this.setState({gridArray:gridTMP});}},{key:\"componentDidMount\",value:function componentDidMount(){this.fillGrid();this.determineArrayDimensions();this.calculateNextGeneration();}},{key:\"render\",value:function render(){var _this3=this;return/*#__PURE__*/_jsxs(\"div\",{className:\"App\",children:[/*#__PURE__*/_jsx(\"header\",{className:\"App-header\"}),/*#__PURE__*/_jsx(\"body\",{children:/*#__PURE__*/_jsxs(\"div\",{className:\"GridDiv\",children:[this.state.gridArray.map(function(Element,index){return/*#__PURE__*/_jsx(Rows,{indexRow:index,value:Element,onCellClick:_this3.onCellClick});}),/*#__PURE__*/_jsx(\"button\",{fill:\"blue\",width:\"100px\",height:\"100px\",onClick:function onClick(){return _this3.stepFunction();},children:\"Play\"})]})})]});}}]);return App;}(Component);export default App;//              { this.state.gridArray.map(Element => Element.map(Element2 => <CellComp value={Element2}/>)) }","map":{"version":3,"sources":["/home/rootuser/Desktop/GameOfLife/gameoflife/src/App.js"],"names":["Component","Rows","App","props","onCellClick","indexCol","indexRow","gridTMP","state","gridArray","setState","biggergridArray","gridXLength","gridYLength","interval","setInterval","calculateNextGeneration","newgridTMP","biggerGrid","index1","index2","row","push","GridAroundCurrentCell3x3","index3","index4","cellsAlive","yLengthTMP","length","xLengthTMP","reduce","x","y","Math","max","fillGrid","determineArrayDimensions","map","Element","index","stepFunction"],"mappings":"4nBAAA,MAAO,WAAP,CACA,OAASA,SAAT,KAA0B,OAA1B,CACA,MAAOC,CAAAA,IAAP,KAAiB,WAAjB,C,2FAEMC,CAAAA,G,0FACJ,aAAYC,KAAZ,CAAkB,qCAChB,uBAAMA,KAAN,EADgB,MAelBC,WAfkB,CAeJ,SAACC,QAAD,CAAWC,QAAX,CAAwB,CACpC,GAAIC,CAAAA,OAAO,CAAG,MAAKC,KAAL,CAAWC,SAAzB,CACAF,OAAO,CAACD,QAAD,CAAP,CAAkBD,QAAlB,EAA8B,CAACE,OAAO,CAACD,QAAD,CAAP,CAAkBD,QAAlB,CAA/B,CAEA,MAAKK,QAAL,CAAc,CAACD,SAAS,CAAEF,OAAZ,CAAd,EACD,CApBiB,CAEhB,MAAKC,KAAL,CAAa,CACX;AACA;AACAC,SAAS,CAAE,EAHA,CAIXE,eAAe,CAAE,EAJN,CAMXC,WAAW,CAAE,GANF,CAOXC,WAAW,CAAE,GAPF,CAAb,CAFgB,aAYjB,CAED;4CAQA;AACA,uBAAc,iBACZ,GAAIC,CAAAA,QAAQ,CAAGC,WAAW,CAAC,iBAAM,CAAA,MAAI,CAACC,uBAAL,EAAN,EAAD,CAAuC,GAAvC,CAA1B,CACA;AACD,CAED;AACA;uCACA,kCAAyB,CACvB,GAAIT,CAAAA,OAAO,CAAG,KAAKC,KAAL,CAAWC,SAAzB,CACA,GAAIQ,CAAAA,UAAU,CAAG,KAAKT,KAAL,CAAWC,SAA5B,CAEA,GAAIS,CAAAA,UAAU,CAAG,EAAjB,CAEA,GAAIC,CAAAA,MAAJ,CAEA;AACA,IAAKA,MAAM,CAAG,CAAd,CAAiBA,MAAM,CAAG,KAAKX,KAAL,CAAWK,WAAX,CAAyB,CAAnD,CAAsDM,MAAM,EAA5D,CAA+D,CAC7D,GAAIC,CAAAA,MAAM,OAAV,CACA,GAAIC,CAAAA,GAAG,CAAG,EAAV,CACA,IAAKD,MAAM,CAAG,CAAd,CAAiBA,MAAM,CAAG,KAAKZ,KAAL,CAAWI,WAAX,CAAyB,CAAnD,CAAsDQ,MAAM,EAA5D,CAA+D,CAE7D;AACA,GAAGD,MAAM,EAAI,CAAV,EAAgBA,MAAM,EAAI,KAAKX,KAAL,CAAWK,WAAX,CAAuB,CAAjD,EAAuDO,MAAM,EAAI,CAAjE,EAAuEA,MAAM,EAAI,KAAKZ,KAAL,CAAWI,WAAX,CAAuB,CAA3G,CAA8G,CAC5GS,GAAG,CAACC,IAAJ,CAAS,KAAT,EACA;AAED,CAED;AANA,IAOI,CACFD,GAAG,CAACC,IAAJ,CAASf,OAAO,CAACY,MAAM,CAAC,CAAR,CAAP,CAAkBC,MAAM,CAAC,CAAzB,CAAT,EACD,CACF,CACDF,UAAU,CAACI,IAAX,CAAgBD,GAAhB,EAED,CAGD,IAAKF,MAAM,CAAG,CAAd,CAAiBA,MAAM,CAAG,KAAKX,KAAL,CAAWK,WAAX,CAAyB,CAAnD,CAAsDM,MAAM,EAA5D,CAA+D,CAC7D,GAAIC,CAAAA,MAAM,OAAV,CACA,GAAIC,CAAAA,IAAG,CAAG,EAAV,CACA,IAAKD,MAAM,CAAG,CAAd,CAAiBA,MAAM,CAAG,KAAKZ,KAAL,CAAWI,WAAX,CAAyB,CAAnD,CAAsDQ,MAAM,EAA5D,CAA+D,CAE7D;AACA,GAAG,EAAED,MAAM,EAAI,CAAV,EAAgBA,MAAM,EAAI,KAAKX,KAAL,CAAWK,WAAX,CAAuB,CAAjD,EAAuDO,MAAM,EAAI,CAAjE,EAAuEA,MAAM,EAAI,KAAKZ,KAAL,CAAWI,WAAX,CAAuB,CAA1G,CAAH,CAAiH,CAC/G,GAAIW,CAAAA,wBAAwB,CAAG,EAA/B,CAEA,GAAIC,CAAAA,MAAM,OAAV,CACA,IAAKA,MAAM,CAAG,CAAd,CAAiBA,MAAM,CAAG,CAA1B,CAA6BA,MAAM,EAAnC,CAAsC,CACpC,GAAIC,CAAAA,MAAM,OAAV,CACA,GAAIJ,CAAAA,KAAG,CAAG,EAAV,CACA,IAAKI,MAAM,CAAG,CAAd,CAAiBA,MAAM,CAAG,CAA1B,CAA6BA,MAAM,EAAnC,CAAsC,CACpCJ,KAAG,CAACC,IAAJ,CAASJ,UAAU,CAACC,MAAM,CAAC,CAAP,CAASK,MAAV,CAAV,CAA4BJ,MAAM,CAAC,CAAP,CAASK,MAArC,CAAT,EACD,CACDF,wBAAwB,CAACD,IAAzB,CAA8BD,KAA9B,EACD,CAED,GAAIK,CAAAA,UAAU,CAAG,CAAjB,CAEA;AACA,IAAKF,MAAM,CAAG,CAAd,CAAiBA,MAAM,CAAG,CAA1B,CAA6BA,MAAM,EAAnC,CAAsC,CACpC,GAAIC,CAAAA,OAAM,OAAV,CACA,IAAKA,OAAM,CAAG,CAAd,CAAiBA,OAAM,CAAG,CAA1B,CAA6BA,OAAM,EAAnC,CAAsC,CACpC,GAAGF,wBAAwB,CAACC,MAAD,CAAxB,CAAiCC,OAAjC,GAA4C,IAA/C,CAAoD,CAClDC,UAAU,GACX,CACF,CACF,CAED;AACA,GAAGH,wBAAwB,CAAC,CAAD,CAAxB,CAA4B,CAA5B,GAAkC,IAArC,CAA0C,CACxCG,UAAU,GACX,CAED;AACA,GAAGA,UAAU,CAAG,CAAhB,CAAkB,CAChBT,UAAU,CAACE,MAAM,CAAC,CAAR,CAAV,CAAqBC,MAAM,CAAC,CAA5B,EAAiC,KAAjC,CACD,CAED,GAAGM,UAAU,EAAI,CAAjB,CAAmB,CACjBT,UAAU,CAACE,MAAM,CAAC,CAAR,CAAV,CAAqBC,MAAM,CAAC,CAA5B,EAAiC,KAAjC,CACD,CAED,GAAGM,UAAU,GAAK,CAAf,EAAoBH,wBAAwB,CAAC,CAAD,CAAxB,CAA4B,CAA5B,GAAkC,KAAzD,CAA+D,CAC7DN,UAAU,CAACE,MAAM,CAAC,CAAR,CAAV,CAAqBC,MAAM,CAAC,CAA5B,EAAiC,IAAjC,CACD,CAED,GAAGM,UAAU,GAAK,CAAf,EAAoBH,wBAAwB,CAAC,CAAD,CAAxB,CAA4B,CAA5B,GAAkC,IAAzD,CAA8D,CAC7D,CAED,GAAGG,UAAU,GAAK,CAAlB,CAAoB,CACnB,CACF,CAKF,CACDR,UAAU,CAACI,IAAX,CAAgBD,IAAhB,EAED,CAGD,KAAKX,QAAL,CAAc,CAAEC,eAAe,CAAEO,UAAnB,CAAd,EACA,KAAKR,QAAL,CAAc,CAACD,SAAS,CAAEQ,UAAZ,CAAd,EACA;AAGD,C,wCAED,mCAA0B,CACxB,GAAIU,CAAAA,UAAU,CAAG,KAAKnB,KAAL,CAAWC,SAAX,CAAqBmB,MAAtC,CACA,GAAIC,CAAAA,UAAU,CAAG,KAAKrB,KAAL,CAAWC,SAAX,CAAqBqB,MAArB,CAA4B,SAACC,CAAD,CAAIC,CAAJ,QAAUC,CAAAA,IAAI,CAACC,GAAL,CAASH,CAAT,CAAYC,CAAC,CAACJ,MAAd,CAAV,EAA5B,CAA6D,CAA7D,CAAjB,CAEA,KAAKlB,QAAL,CAAc,CAACE,WAAW,CAAEiB,UAAd,CAAd,EACA,KAAKnB,QAAL,CAAc,CAACG,WAAW,CAAEc,UAAd,CAAd,EAGD,C,wBAED,mBAAU,CACR,GAAIpB,CAAAA,OAAO,CAAG,KAAKC,KAAL,CAAWC,SAAzB,CAEA,GAAIU,CAAAA,MAAJ,CAEA;AACA,IAAKA,MAAM,CAAG,CAAd,CAAiBA,MAAM,CAAG,KAAKX,KAAL,CAAWK,WAArC,CAAkDM,MAAM,EAAxD,CAA2D,CACzD,GAAIC,CAAAA,MAAM,OAAV,CACA,GAAIC,CAAAA,GAAG,CAAG,EAAV,CACA,IAAKD,MAAM,CAAG,CAAd,CAAiBA,MAAM,CAAG,KAAKZ,KAAL,CAAWI,WAArC,CAAkDQ,MAAM,EAAxD,CAA2D,CACzDC,GAAG,CAACC,IAAJ,CAAS,KAAT,EACD,CACDf,OAAO,CAACe,IAAR,CAAaD,GAAb,EACD,CAED,KAAKX,QAAL,CAAc,CAAED,SAAS,CAAEF,OAAb,CAAd,EAED,C,iCAED,4BAAmB,CACjB,KAAK4B,QAAL,GACA,KAAKC,wBAAL,GACA,KAAKpB,uBAAL,GAED,C,sBAED,iBAAQ,iBAEN,mBAEE,aAAK,SAAS,CAAC,KAAf,wBACE,eAAQ,SAAS,CAAC,YAAlB,EADF,cAIE,mCAEI,aAAK,SAAS,CAAC,SAAf,WACI,KAAKR,KAAL,CAAWC,SAAX,CAAqB4B,GAArB,CAAyB,SAACC,OAAD,CAAUC,KAAV,qBAAmB,KAAC,IAAD,EAAM,QAAQ,CAAEA,KAAhB,CAAuB,KAAK,CAAED,OAA9B,CAAuC,WAAW,CAAE,MAAI,CAAClC,WAAzD,EAAnB,EAAzB,CADJ,cAGE,eAAQ,IAAI,CAAC,MAAb,CAAoB,KAAK,CAAC,OAA1B,CAAkC,MAAM,CAAC,OAAzC,CAAiD,OAAO,CAAE,yBAAM,CAAA,MAAI,CAACoC,YAAL,EAAN,EAA1D,kBAHF,GAFJ,EAJF,GAFF,CAiBD,C,iBA7LexC,S,EAiMlB,cAAeE,CAAAA,GAAf,CACA","sourcesContent":["import './App.css';\nimport { Component } from 'react';\nimport Rows from './Rows.js';\n\nclass App extends Component {\n  constructor(props){\n    super(props);\n    this.state = {\n      //gridArray:[ [ \"1\", \"2\", \"3\"], [ \"4\", \"5\" , \"6\"], [ \"6\", \"7\" , \"8\"] ],\n      //gridArray:[ [ true, false, false], [ false, true , false], [ true, false , true] , [ false, false , false]],\n      gridArray: [],\n      biggergridArray: [],\n\n      gridXLength: 100,\n      gridYLength: 100,\n\n    }\n  }\n\n  // When clicked on a Cell, then switch that cells status.\n  onCellClick = (indexCol, indexRow) => {\n    let gridTMP = this.state.gridArray;\n    gridTMP[indexRow][indexCol] = !gridTMP[indexRow][indexCol];\n\n    this.setState({gridArray: gridTMP});\n  }\n\n  // Function to call when the button is clicked.\n  stepFunction(){\n    var interval = setInterval(() => this.calculateNextGeneration(), 200);\n    //this.calculateNextGeneration()\n  }\n\n  // Function to calculate the next generation of hte current grid,\n  // according to the rules of the game of life.\n  calculateNextGeneration(){\n    let gridTMP = this.state.gridArray;\n    let newgridTMP = this.state.gridArray;\n\n    let biggerGrid = [];\n\n    let index1;\n\n    // Fill the bigger Grid with false.\n    for (index1 = 0; index1 < this.state.gridYLength + 2; index1++){\n      let index2;\n      let row = [];\n      for (index2 = 0; index2 < this.state.gridXLength + 2; index2++){\n        \n        // If the current cell is on the outermost loop of the bigger grid, fill it with false.\n        if(index1 == 0 || (index1 == this.state.gridYLength+1) || index2 == 0 || (index2 == this.state.gridXLength+1)){\n          row.push(false);\n          //console.log(index1 + \" \" + index2);\n\n        }\n\n        // If the current cell is NOT on the outermost loop of the bigger grid, fill it with the content the the grid.\n        else{\n          row.push(gridTMP[index1-1][index2-1]);\n        }\n      }\n      biggerGrid.push(row)\n\n    }\n\n\n    for (index1 = 0; index1 < this.state.gridYLength + 2; index1++){\n      let index2;\n      let row = [];\n      for (index2 = 0; index2 < this.state.gridXLength + 2; index2++){\n        \n        // If the current cell is NOT on the outermost loop of the bigger grid, do the game of life things.\n        if(!(index1 == 0 || (index1 == this.state.gridYLength+1) || index2 == 0 || (index2 == this.state.gridXLength+1))){\n          let GridAroundCurrentCell3x3 = [];\n\n          let index3;\n          for (index3 = 0; index3 < 3; index3++){\n            let index4;\n            let row = [];\n            for (index4 = 0; index4 < 3; index4++){\n              row.push(biggerGrid[index1-1+index3][index2-1+index4]);\n            }     \n            GridAroundCurrentCell3x3.push(row);\n          }\n\n          let cellsAlive = 0;\n\n          // Count the number of alive cells in the current 3x3 grid.\n          for (index3 = 0; index3 < 3; index3++){\n            let index4;\n            for (index4 = 0; index4 < 3; index4++){\n              if(GridAroundCurrentCell3x3[index3][index4] == true){\n                cellsAlive++;\n              }\n            }     \n          }\n\n          // Simply reduce number of Cells alive by one if the current cell is alive itself.\n          if(GridAroundCurrentCell3x3[1][1] == true){\n            cellsAlive--;\n          }\n\n          // Check for which rule to apply.\n          if(cellsAlive < 2){\n            newgridTMP[index1-1][index2-1] = false;\n          }\n\n          if(cellsAlive >= 4){\n            newgridTMP[index1-1][index2-1] = false;\n          }\n\n          if(cellsAlive === 3 && GridAroundCurrentCell3x3[1][1] == false){\n            newgridTMP[index1-1][index2-1] = true;\n          }\n\n          if(cellsAlive === 3 && GridAroundCurrentCell3x3[1][1] == true){\n          }\n\n          if(cellsAlive === 2){\n          }\n        }\n        \n        \n\n\n      }\n      biggerGrid.push(row)\n\n    }\n\n\n    this.setState({ biggergridArray: biggerGrid});\n    this.setState({gridArray: newgridTMP})\n    //this.setState({ gridArray: biggerGrid});  // Use this line instead of the one above, to display the bigger grid instead of the original. \n\n\n  }\n\n  determineArrayDimensions(){\n    let yLengthTMP = this.state.gridArray.length;\n    let xLengthTMP = this.state.gridArray.reduce((x, y) => Math.max(x, y.length), 0);\n\n    this.setState({gridXLength: xLengthTMP});\n    this.setState({gridYLength: yLengthTMP});\n\n\n  }\n  \n  fillGrid(){\n    let gridTMP = this.state.gridArray;\n\n    let index1;\n\n    // Fill Grid with false.\n    for (index1 = 0; index1 < this.state.gridYLength; index1++){\n      let index2;\n      let row = [];\n      for (index2 = 0; index2 < this.state.gridXLength; index2++){\n        row.push(false);\n      }\n      gridTMP.push(row)\n    }\n    \n    this.setState({ gridArray: gridTMP});\n\n  }\n\n  componentDidMount(){\n    this.fillGrid(); \n    this.determineArrayDimensions();\n    this.calculateNextGeneration();\n\n  }\n\n  render(){\n\n    return (\n      \n      <div className=\"App\">\n        <header className=\"App-header\">\n        </header>\n  \n        <body>\n\n            <div className=\"GridDiv\">\n              { this.state.gridArray.map((Element, index)=> <Rows indexRow={index} value={Element} onCellClick={this.onCellClick}/>) }\n\n              <button fill=\"blue\" width=\"100px\" height=\"100px\" onClick={() => this.stepFunction()}>Play</button>\n            </div>\n\n        </body>\n      </div>\n    );\n  }\n\n}\n\nexport default App;\n//              { this.state.gridArray.map(Element => Element.map(Element2 => <CellComp value={Element2}/>)) }\n"]},"metadata":{},"sourceType":"module"}