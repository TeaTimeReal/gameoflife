{"ast":null,"code":"import _classCallCheck from\"/home/rootuser/Desktop/GameOfLife/gameoflife/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/rootuser/Desktop/GameOfLife/gameoflife/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"/home/rootuser/Desktop/GameOfLife/gameoflife/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/home/rootuser/Desktop/GameOfLife/gameoflife/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import'./App.css';import{Component}from'react';import Rows from'./Rows.js';import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var App=/*#__PURE__*/function(_Component){_inherits(App,_Component);var _super=_createSuper(App);function App(props){var _this;_classCallCheck(this,App);_this=_super.call(this,props);_this.onCellClick=function(indexCol,indexRow){var gridTMP=_this.state.gridArray;gridTMP[indexRow][indexCol]=!gridTMP[indexRow][indexCol];_this.setState({gridArray:gridTMP});};_this.fillGrid=function(gridXLength,gridYLength){var gridTMP=[];var index1;// Fill Grid with false.\nfor(index1=0;index1<gridYLength;index1++){var index2=void 0;var row=[];for(index2=0;index2<gridXLength;index2++){row.push(false);}gridTMP.push(row);}_this.setState({gridArray:gridTMP});};_this.state={gridArray:[],gridXLength:10,//prompt(\"length\"),\ngridYLength:10//prompt(\"height\"),\n};return _this;}// When clicked on a Cell, then switch that cells status.\n_createClass(App,[{key:\"stepFunction\",value:// Function to call when the button is clicked.\nfunction stepFunction(){var _this2=this;setInterval(function(){return _this2.calculateNextGeneration();},20);//this.calculateNextGeneration()\n}// Function to calculate the next generation of hte current grid,\n// according to the rules of the game of life.\n},{key:\"calculateNextGeneration\",value:function calculateNextGeneration(){var gridTMP=this.state.gridArray;var newgridTMP=this.state.gridArray;var biggerGrid=[];var index1;// Fill the bigger Grid with the original grid and an outer line of cells with false.\nfor(index1=0;index1<this.state.gridYLength+2;index1++){var index2=void 0;var row=[];for(index2=0;index2<this.state.gridXLength+2;index2++){// If the current cell is on the outermost loop of the bigger grid, fill it with false.\nif(index1===0||index1===this.state.gridYLength+1||index2===0||index2===this.state.gridXLength+1){row.push(false);}// If the current cell is NOT on the outermost loop of the bigger grid, fill it with the content the the grid.\nelse{row.push(gridTMP[index1-1][index2-1]);}}biggerGrid.push(row);}for(index1=0;index1<this.state.gridYLength+2;index1++){var _index=void 0;var _row=[];for(_index=0;_index<this.state.gridXLength+2;_index++){// If the current cell is NOT on the outermost loop of the bigger grid, do the game of life things.\nif(!(index1===0||index1===this.state.gridYLength+1||_index===0||_index===this.state.gridXLength+1)){var GridAroundCurrentCell3x3=[];var index3=void 0;for(index3=0;index3<3;index3++){var index4=void 0;var _row2=[];for(index4=0;index4<3;index4++){_row2.push(biggerGrid[index1-1+index3][_index-1+index4]);}GridAroundCurrentCell3x3.push(_row2);}var cellsAlive=0;// Count the number of alive cells in the current 3x3 grid.\nfor(index3=0;index3<3;index3++){var _index2=void 0;for(_index2=0;_index2<3;_index2++){if(GridAroundCurrentCell3x3[index3][_index2]===true){cellsAlive++;}}}// Simply reduce number of Cells alive by one if the current cell is alive itself.\nif(GridAroundCurrentCell3x3[1][1]===true){cellsAlive--;}// Check for which rule to apply.\nif(cellsAlive<2){newgridTMP[index1-1][_index-1]=false;}if(cellsAlive>=4){newgridTMP[index1-1][_index-1]=false;}if(cellsAlive===3&&GridAroundCurrentCell3x3[1][1]===false){newgridTMP[index1-1][_index-1]=true;}if(cellsAlive===3&&GridAroundCurrentCell3x3[1][1]===true){}if(cellsAlive===2){}}}biggerGrid.push(_row);}this.setState({gridArray:newgridTMP});//this.setState({ gridArray: biggerGrid});  // Use this line instead of the one above, to display the bigger grid instead of the original. \n}},{key:\"componentDidMount\",value:function componentDidMount(){var gridXLengthtmp=prompt(\"Length\");var gridYHeigthtmp=prompt(\"Heigth\");this.setState({gridXLength:Number(gridXLengthtmp)});this.setState({gridYLength:Number(gridYHeigthtmp)});//alert(typeof(this.state.gridXLength) + this.state.gridXLength);\nthis.fillGrid(gridXLengthtmp,gridYHeigthtmp);}},{key:\"render\",value:function render(){var _this3=this;return/*#__PURE__*/_jsxs(\"div\",{className:\"App\",children:[/*#__PURE__*/_jsx(\"header\",{className:\"App-header\"}),/*#__PURE__*/_jsx(\"body\",{children:/*#__PURE__*/_jsxs(\"div\",{className:\"GridDiv\",children:[this.state.gridArray.map(function(Element,index){return/*#__PURE__*/_jsx(Rows,{indexRow:index,value:Element,onCellClick:_this3.onCellClick});}),/*#__PURE__*/_jsx(\"button\",{fill:\"blue\",width:\"100px\",height:\"100px\",onClick:function onClick(){return _this3.stepFunction();},children:\"Play\"})]})})]});}}]);return App;}(Component);export default App;","map":{"version":3,"sources":["/home/rootuser/Desktop/GameOfLife/gameoflife/src/App.js"],"names":["Component","Rows","App","props","onCellClick","indexCol","indexRow","gridTMP","state","gridArray","setState","fillGrid","gridXLength","gridYLength","index1","index2","row","push","setInterval","calculateNextGeneration","newgridTMP","biggerGrid","GridAroundCurrentCell3x3","index3","index4","cellsAlive","gridXLengthtmp","prompt","gridYHeigthtmp","Number","map","Element","index","stepFunction"],"mappings":"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","sourcesContent":["import './App.css';\nimport { Component } from 'react';\nimport Rows from './Rows.js';\n\nclass App extends Component {\n  constructor(props){\n    super(props);\n    this.state = {\n      gridArray: [],\n\n      gridXLength: 10,//prompt(\"length\"),\n      gridYLength: 10,//prompt(\"height\"),\n\n    }\n  }\n\n  // When clicked on a Cell, then switch that cells status.\n  onCellClick = (indexCol, indexRow) => {\n    let gridTMP = this.state.gridArray;\n    gridTMP[indexRow][indexCol] = !gridTMP[indexRow][indexCol];\n\n    this.setState({gridArray: gridTMP});\n  }\n\n  // Function to call when the button is clicked.\n  stepFunction(){\n    setInterval(() => this.calculateNextGeneration(), 20);\n\n    //this.calculateNextGeneration()\n  }\n\n  // Function to calculate the next generation of hte current grid,\n  // according to the rules of the game of life.\n  calculateNextGeneration(){\n    let gridTMP = this.state.gridArray;\n    let newgridTMP = this.state.gridArray;\n\n    let biggerGrid = [];\n\n    let index1;\n\n    // Fill the bigger Grid with the original grid and an outer line of cells with false.\n    for (index1 = 0; index1 < this.state.gridYLength + 2; index1++){\n      let index2;\n      let row = [];\n      for (index2 = 0; index2 < this.state.gridXLength + 2; index2++){\n        \n        // If the current cell is on the outermost loop of the bigger grid, fill it with false.\n        if(index1 === 0 || (index1 === this.state.gridYLength+1) || index2 === 0 || (index2 === this.state.gridXLength+1)){\n          row.push(false);\n        }\n\n        // If the current cell is NOT on the outermost loop of the bigger grid, fill it with the content the the grid.\n        else{\n          row.push(gridTMP[index1-1][index2-1]);\n        }\n      }\n      biggerGrid.push(row)\n\n    }\n\n\n    for (index1 = 0; index1 < this.state.gridYLength + 2; index1++){\n      let index2;\n      let row = [];\n      for (index2 = 0; index2 < this.state.gridXLength + 2; index2++){\n        \n        // If the current cell is NOT on the outermost loop of the bigger grid, do the game of life things.\n        if(!(index1 === 0 || (index1 === this.state.gridYLength+1) || index2 === 0 || (index2 === this.state.gridXLength+1))){\n          let GridAroundCurrentCell3x3 = [];\n\n          let index3;\n          for (index3 = 0; index3 < 3; index3++){\n            let index4;\n            let row = [];\n            for (index4 = 0; index4 < 3; index4++){\n              row.push(biggerGrid[index1-1+index3][index2-1+index4]);\n            }     \n            GridAroundCurrentCell3x3.push(row);\n          }\n\n          let cellsAlive = 0;\n\n          // Count the number of alive cells in the current 3x3 grid.\n          for (index3 = 0; index3 < 3; index3++){\n            let index4;\n            for (index4 = 0; index4 < 3; index4++){\n              if(GridAroundCurrentCell3x3[index3][index4] === true){\n                cellsAlive++;\n              }\n            }     \n          }\n\n          // Simply reduce number of Cells alive by one if the current cell is alive itself.\n          if(GridAroundCurrentCell3x3[1][1] === true){\n            cellsAlive--;\n          }\n\n          // Check for which rule to apply.\n          if(cellsAlive < 2){\n            newgridTMP[index1-1][index2-1] = false;\n          }\n\n          if(cellsAlive >= 4){\n            newgridTMP[index1-1][index2-1] = false;\n          }\n\n          if(cellsAlive === 3 && GridAroundCurrentCell3x3[1][1] === false){\n            newgridTMP[index1-1][index2-1] = true;\n          }\n\n          if(cellsAlive === 3 && GridAroundCurrentCell3x3[1][1] === true){\n          }\n\n          if(cellsAlive === 2){\n          }\n        }\n      \n      }\n      biggerGrid.push(row)\n\n    }\n\n\n    this.setState({gridArray: newgridTMP})\n    //this.setState({ gridArray: biggerGrid});  // Use this line instead of the one above, to display the bigger grid instead of the original. \n\n\n  }\n\n  \n  fillGrid = (gridXLength, gridYLength) => {\n    let gridTMP = [];\n\n    let index1;\n    // Fill Grid with false.\n    for (index1 = 0; index1 < gridYLength; index1++){\n      let index2;\n      let row = [];\n      for (index2 = 0; index2 < gridXLength; index2++){\n        row.push(false);\n      }\n      gridTMP.push(row)\n    }\n    \n    this.setState({ gridArray: gridTMP});\n\n\n  }\n\n\n  componentDidMount(){\n    const gridXLengthtmp = prompt(\"Length\");\n    const gridYHeigthtmp = prompt(\"Heigth\");\n\n    this.setState({ gridXLength: Number(gridXLengthtmp)});\n    this.setState({ gridYLength: Number(gridYHeigthtmp)});\n\n    \n    //alert(typeof(this.state.gridXLength) + this.state.gridXLength);\n\n    this.fillGrid(gridXLengthtmp, gridYHeigthtmp); \n  }\n\n\n  render(){\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n        </header>\n  \n        <body>\n\n            <div className=\"GridDiv\">\n              { this.state.gridArray.map((Element, index)=> <Rows indexRow={index} value={Element} onCellClick={this.onCellClick}/>) }\n\n              <button fill=\"blue\" width=\"100px\" height=\"100px\" onClick={() => this.stepFunction()}>Play</button>\n            </div>\n\n        </body>\n      </div>\n    );\n  }\n\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}